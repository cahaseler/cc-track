# Plan: 043

Captured: 2025-09-13T22:25:08.123Z

## Plan: Integrate DiffSummary into Stop-Review Hook for Token Reduction

### Current Analysis

**Stop-Review Hook Current Flow:**
1. Gets git diff (up to 5MB) and filters out documentation files
2. Truncates diff to 10,000 chars in the prompt (line 383)
3. Sends to **Sonnet** model for review (more expensive, line 438)
4. Total prompt can exceed 20,000 chars frequently

**DiffSummary Tool Capabilities:**
- Uses **Haiku** model (confirmed, line 94 in diff-summary.ts) - much cheaper and faster
- Truncates individual diffs to 3,000 chars before processing
- Can process multiple diffs in parallel
- Produces concise summaries (<500 chars per diff)

### Implementation Strategy

#### 1. Split Large Diffs by File
Instead of sending one massive diff, split it into per-file diffs:
- Parse the filtered diff to extract individual file changes
- Group files logically (e.g., related test files, same directory)
- Each group becomes a chunk for summarization

#### 2. Parallel Summarization with Haiku
Process chunks in parallel using DiffSummary:
```typescript
// Pseudo-code
const chunks = splitDiffIntoFileGroups(filteredDiff, MAX_CHUNK_SIZE);
const summaryPromises = chunks.map(chunk => diffSummary.summarizeDiff(chunk));
const summaries = await Promise.all(summaryPromises);
const combinedSummary = summaries.join('\n\n');
```

#### 3. Two-Stage Review Process
- **Stage 1**: Use DiffSummary with Haiku to compress the diff
  - Input: Full filtered diff (could be 50,000+ chars)
  - Output: Compressed summary (~2,000 chars)
  
- **Stage 2**: Send compressed summary to Sonnet for deviation detection
  - Include: Task requirements, recent messages, compressed diff summary
  - Sonnet focuses on high-level review without parsing raw diffs

### Detailed Implementation Plan

#### Files to Modify:

1. **src/hooks/stop-review.ts**
   - Add DiffSummary to dependencies interface
   - Create new method `compressDiffForReview()`
   - Modify `buildReviewPrompt()` to use compressed diff
   - Update `review()` method to call compression before building prompt

2. **src/hooks/stop-review.test.ts** 
   - Add tests for diff compression
   - Mock DiffSummary in test dependencies
   - Test parallel summarization behavior

### Key Implementation Details:

#### A. Diff Splitting Logic
```typescript
private splitDiffIntoChunks(diff: string, maxChunkSize: number = 8000): string[] {
  const chunks: string[] = [];
  const lines = diff.split('\n');
  let currentChunk: string[] = [];
  let currentSize = 0;
  
  for (const line of lines) {
    if (line.startsWith('diff --git')) {
      // Start of new file
      if (currentSize > maxChunkSize && currentChunk.length > 0) {
        chunks.push(currentChunk.join('\n'));
        currentChunk = [];
        currentSize = 0;
      }
    }
    currentChunk.push(line);
    currentSize += line.length;
  }
  
  if (currentChunk.length > 0) {
    chunks.push(currentChunk.join('\n'));
  }
  
  return chunks;
}
```

#### B. Compression Method
```typescript
private async compressDiffForReview(diff: string): Promise<string> {
  const diffSummaryTool = this.deps.diffSummary || new DiffSummary();
  
  // If diff is small, don't compress
  if (diff.length < 5000) {
    return diff;
  }
  
  try {
    // Split into manageable chunks
    const chunks = this.splitDiffIntoChunks(diff);
    
    // Summarize in parallel (max 5 concurrent)
    const batchSize = 5;
    const summaries: string[] = [];
    
    for (let i = 0; i < chunks.length; i += batchSize) {
      const batch = chunks.slice(i, i + batchSize);
      const batchSummaries = await Promise.all(
        batch.map(chunk => diffSummaryTool.summarizeDiff(chunk))
      );
      summaries.push(...batchSummaries);
    }
    
    // Combine summaries with file indicators
    const combined = summaries.map((s, i) => 
      `Change Set ${i + 1}:\n${s}`
    ).join('\n\n');
    
    this.logger.info('Diff compression stats', {
      originalSize: diff.length,
      compressedSize: combined.length,
      compressionRatio: (1 - combined.length / diff.length).toFixed(2)
    });
    
    return combined;
  } catch (error) {
    this.logger.warn('Diff compression failed, using truncated original', { error });
    return diff.substring(0, 10000);
  }
}
```

#### C. Modified Review Prompt
Update buildReviewPrompt to indicate when using compressed diff:
```typescript
const isCompressed = diff.includes('Change Set');
const diffSection = isCompressed
  ? `## Compressed Git Diff Summary (via Haiku):\n${diff}`
  : `## Git Diff (code changes only):\n\`\`\`diff\n${diff.substring(0, 10000)}\n\`\`\``;
```

### Benefits

1. **Token Reduction**: 
   - Original: 10,000+ chars of raw diff → Sonnet
   - New: 2,000 chars of summaries → Sonnet
   - Compression ratio: ~80% reduction

2. **Cost Savings**:
   - Haiku for compression: ~$0.25 per million tokens
   - Sonnet for review: ~$3 per million tokens
   - Moving bulk processing to Haiku saves ~90% on that portion

3. **Speed Improvement**:
   - Parallel processing with Haiku (faster model)
   - Smaller prompt for Sonnet = faster response

4. **Better Reviews**:
   - Sonnet receives pre-digested information
   - Focus on semantic changes rather than parsing syntax
   - Less likely to hit token limits

### Edge Cases to Handle

1. **Very small diffs** (<5KB): Skip compression, use original
2. **Compression failure**: Fallback to truncated original diff
3. **Parallel API limits**: Batch requests to avoid rate limiting
4. **Mixed changes**: Ensure file boundaries are preserved in chunks
5. **Empty summaries**: Handle cases where Haiku returns minimal output

### Testing Strategy

1. Unit tests with mocked DiffSummary
2. Test compression with various diff sizes
3. Test fallback behavior on compression failure
4. Integration test with real diffs
5. Verify Sonnet still detects deviations correctly with compressed input

This approach maintains the stop-review hook's deviation detection capability while significantly reducing token usage and improving performance.