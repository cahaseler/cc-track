# Plan: 012

Captured: 2025-09-10T14:17:51.887Z

# Debug Capture Plan Approval Issue

## Problem Summary
The capture_plan hook is not creating tasks when plans are approved in real sessions. From existing logs, I can see the issue: the hook checks for `tool_response?.success` but real ExitPlanMode responses may have different structures.

## Investigation Process

### 1. Analyze Current Log Evidence
- Review the 5 existing capture_plan log entries in `2025-09-10.jsonl`
- Two test entries show the expected pattern: `{"success": true}` works, `{}` doesn't
- Determine what real ExitPlanMode tool responses look like vs test data

### 2. Examine ExitPlanMode Tool Response Structure  
- Check Claude Code documentation or test with actual planning session
- Compare real tool_response structure to what the hook expects
- Identify if the approval detection logic needs adjustment
- **Investigate both approval methods**: "approve with manual edits" vs "approve with automatic edits" - they may give different responses

### 3. Review Hook Logic
- Examine the `!data.tool_response?.success` condition in capture_plan.ts:48
- Determine if this is the correct way to detect plan approval
- Consider alternative detection methods if needed

### 4. Test with Real Data
- Trigger an actual planning session (shift-tab → plan → approve)
- Test both approval methods to capture different response structures
- Capture the real tool_response structure in logs
- Verify if the issue is in the detection logic or response format

### 5. Fix Detection Logic (if needed)
- Update the approval detection condition based on real response structure
- Add more robust logging to capture edge cases
- Test the fix with another planning session

### 6. Validate Fix
- Confirm task creation works with real approved plans
- Verify rejected plans still don't create tasks
- Update any related documentation

## Expected Outcome
Working plan approval detection that creates tasks when plans are approved and skips creation when plans are rejected, with comprehensive logging for future debugging.