# Plan: 026

Captured: 2025-09-11T03:02:22.635Z

## Refactor cc-track to CLI Tool Architecture with Tests

### Phase 1: Create /src folder structure with tests
```
/src/
â”œâ”€â”€ cli.ts                    # Main CLI entry point with commander setup
â”œâ”€â”€ commands/                 # CLI command implementations
â”‚   â”œâ”€â”€ hook.ts               # Hook execution dispatcher (handles stdin/stdout)
â”‚   â”œâ”€â”€ init.ts               # Initialize cc-track in a project
â”‚   â”œâ”€â”€ backlog.ts            # Add items to backlog
â”‚   â”œâ”€â”€ complete-task.ts      # Complete active task
â”‚   â””â”€â”€ git-session.ts        # Git session utilities
â”œâ”€â”€ hooks/                    # Hook implementations (pure functions)
â”‚   â”œâ”€â”€ capture-plan.ts       # Returns HookOutput from HookInput
â”‚   â”œâ”€â”€ capture-plan.test.ts  # Tests with mock inputs
â”‚   â”œâ”€â”€ pre-compact.ts        # Returns HookOutput from HookInput
â”‚   â”œâ”€â”€ pre-compact.test.ts   # Tests with mock inputs
â”‚   â”œâ”€â”€ post-compact.ts       # Returns HookOutput from HookInput
â”‚   â”œâ”€â”€ stop-review.ts        # Returns HookOutput from HookInput
â”‚   â”œâ”€â”€ stop-review.test.ts   # Tests with mock inputs
â”‚   â”œâ”€â”€ edit-validation.ts    # Returns HookOutput from HookInput
â”‚   â””â”€â”€ edit-validation.test.ts # Tests with mock inputs
â””â”€â”€ lib/                      # Shared libraries
    â”œâ”€â”€ config.ts             # Configuration management
    â”œâ”€â”€ config.test.ts        # Tests for config functions
    â”œâ”€â”€ logger.ts             # Logging utilities
    â”œâ”€â”€ logger.test.ts        # Tests for logger
    â”œâ”€â”€ git-helpers.ts        # Git operations
    â”œâ”€â”€ git-helpers.test.ts   # Tests for git helpers
    â”œâ”€â”€ github-helpers.ts     # GitHub CLI wrappers
    â””â”€â”€ github-helpers.test.ts # Tests for github helpers
```

### Phase 2: Add dependencies
```bash
bun add commander
# Bun test is built-in, no additional testing deps needed
```

### Phase 3: Hook Architecture Transformation

#### Current (stdin/stdout based):
```typescript
// .claude/hooks/capture_plan.ts
#!/usr/bin/env bun
const input = await Bun.stdin.text();
const data = JSON.parse(input);
// ... process ...
console.log(JSON.stringify({ continue: true, systemMessage: "..." }));
```

#### New (pure function):
```typescript
// src/hooks/capture-plan.ts
import type { HookInput, HookOutput } from '../types';

export async function captureplanHook(input: HookInput): Promise<HookOutput> {
  // All the existing logic, but:
  // - Takes input as parameter instead of stdin
  // - Returns output instead of console.log
  // - Throws errors instead of process.exit(1)
  
  if (!input.tool_response?.plan) {
    return { continue: true };
  }
  
  // ... existing task creation logic ...
  
  return {
    continue: true,
    systemMessage: `Task ${taskNumber} created`
  };
}
```

#### Hook dispatcher (handles stdin/stdout):
```typescript
// src/commands/hook.ts
import { captureplanHook } from '../hooks/capture-plan';
import { preCompactHook } from '../hooks/pre-compact';
// ... other imports

export async function executeHook(hookType: string, options: any) {
  try {
    // Read from stdin once, here
    const input = await Bun.stdin.text();
    const data = JSON.parse(input);
    
    let output: HookOutput;
    
    // Dispatch to appropriate hook function
    switch(hookType) {
      case 'capture-plan':
        output = await captureplanHook(data);
        break;
      case 'pre-compact':
        output = await preCompactHook(data);
        break;
      case 'post-compact':
        output = await postCompactHook(data);
        break;
      case 'stop-review':
        output = await stopReviewHook(data);
        break;
      case 'edit-validation':
        output = await editValidationHook(data);
        break;
      default:
        throw new Error(`Unknown hook type: ${hookType}`);
    }
    
    // Write to stdout once, here
    console.log(JSON.stringify(output));
    process.exit(0);
  } catch (error) {
    console.error(JSON.stringify({ error: error.message }));
    process.exit(1);
  }
}
```

### Phase 4: Testing Strategy

#### Simple, focused tests for hooks:
```typescript
// src/hooks/capture-plan.test.ts
import { describe, expect, test, mock } from "bun:test";
import { captureplanHook } from "./capture-plan";

describe("capture-plan hook", () => {
  test("returns continue when no plan provided", async () => {
    const input = { tool_response: {} };
    const output = await captureplanHook(input);
    expect(output.continue).toBe(true);
    expect(output.systemMessage).toBeUndefined();
  });
  
  test("creates task when plan is approved", async () => {
    // Mock file system operations
    mock.module("node:fs", () => ({
      existsSync: () => true,
      readFileSync: () => "# No active task",
      writeFileSync: mock(() => {}),
      readdirSync: () => ["TASK_001.md", "TASK_002.md"]
    }));
    
    const input = {
      tool_response: { plan: "Build awesome feature" },
      cwd: "/test/project"
    };
    
    const output = await captureplanHook(input);
    
    expect(output.continue).toBe(true);
    expect(output.systemMessage).toContain("TASK_003");
  });
});
```

#### Test library functions:
```typescript
// src/lib/config.test.ts
import { describe, expect, test } from "bun:test";
import { getConfig, isHookEnabled } from "./config";

describe("config", () => {
  test("returns default config when file missing", () => {
    const config = getConfig();
    expect(config.features).toBeDefined();
  });
  
  test("isHookEnabled checks feature flags", () => {
    // Test with mock config
    expect(isHookEnabled("capture_plan")).toBe(true);
  });
});
```

### Phase 5: CLI Structure with Commander
```typescript
// src/cli.ts
#!/usr/bin/env bun
import { Command } from 'commander';
import { executeHook } from './commands/hook';
import { initCommand } from './commands/init';
import { backlogCommand } from './commands/backlog';
import { completeTaskCommand } from './commands/complete-task';

const program = new Command()
  .name('cc-track')
  .description('Task Review And Context Keeper ðŸš…')
  .version('1.0.0');

// Hook command: cc-track hook <type>
program.command('hook <type>')
  .description('Execute a cc-track hook')
  .action(executeHook);

// Init command: cc-track init
program.command('init')
  .description('Initialize cc-track in a project')
  .option('--stop-review', 'Enable stop review hook')
  .action(initCommand);

// Backlog command: cc-track backlog <item>
program.command('backlog <item>')
  .description('Add an item to the backlog')
  .action(backlogCommand);

// Complete task command: cc-track complete-task
program.command('complete-task')
  .description('Complete the active task')
  .action(completeTaskCommand);

program.parse();
```

### Phase 6: Migration Process

1. **Copy lib files first** - They're already mostly pure functions
2. **Write tests for each lib function** - Ensure behavior preserved
3. **Copy and refactor hooks** - Remove stdin/stdout, make them pure functions
4. **Write tests for hooks** - Mock file system and external commands
5. **Implement CLI commands** - Thin wrappers around tested functions
6. **Build and test compiled binary**
7. **Update settings.json** - Replace `bun run` with `cc-track hook`

### Phase 7: Update settings.json (after testing)
```json
{
  "hooks": {
    "PostToolUse": [{
      "matcher": "ExitPlanMode",
      "hooks": [{
        "type": "command",
        "command": "./cc-track hook capture-plan",  // Changed from bun run
        "timeout": 10000
      }]
    }]
    // ... other hooks similar pattern
  }
}
```

### Benefits of this approach:
- **Testable**: Hooks are pure functions, easy to test
- **Single stdin/stdout handler**: All IO in one place (commands/hook.ts)
- **Maintainable**: Clear separation between business logic and IO
- **Backwards compatible**: Same JSON interface for Claude Code
- **Professional CLI**: Commander gives us help, version, error handling
- **Fast tests**: Bun test runs quickly, no complex stdin/stdout mocking

### Package.json scripts:
```json
"scripts": {
  "build": "bun build --compile --minify ./src/cli.ts --outfile cc-track",
  "dev": "bun run ./src/cli.ts",
  "test": "bun test",
  "test:watch": "bun test --watch",
  "test:coverage": "bun test --coverage"
}
```

### Safety measures:
- Keep original .claude/ files untouched during development
- Test each hook with both `bun run dev hook <type>` and compiled binary
- Verify JSON input/output compatibility before updating settings.json
- Can rollback at any point by reverting settings.json