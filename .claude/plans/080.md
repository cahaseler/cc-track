# Plan: 080

Captured: 2025-09-18T17:32:09.140Z

## Integration Testing Plan for cc-track

### Overview
Add comprehensive integration tests to validate multi-component workflows and real-world scenarios that unit tests can't cover. Focus on high-value paths that users actually experience.

### Test Categories

#### 1. **Task Lifecycle Integration Tests** (~5 tests)
Test the complete flow from plan capture through task completion:
- `capture-plan → task creation → branch creation → development → validation → completion → PR`
- Include scenarios with and without GitHub integration
- Test task status transitions and file updates
- Validate git operations (commits, branches, squashing)

#### 2. **Hook Chain Integration Tests** (~4 tests)
Test sequences of hooks firing in real workflows:
- Edit file → edit-validation → stop-review → auto-commit
- Plan exit → capture-plan → GitHub issue → branch creation
- Complete task → validation → squash commits → PR creation → branch switch
- Test hook blocking/continuation logic

#### 3. **Git Operations Integration Tests** (~3 tests)
Use temporary git repositories to test real git operations:
- Branch creation, switching, and protection
- WIP commit creation and squashing
- Diverged branch handling with rebasing
- Git configuration and state management

#### 4. **Context Management Integration Tests** (~2 tests)
Test the CLAUDE.md import system and context file updates:
- Task file imports and updates
- Progress log maintenance
- Decision log entries
- Dynamic vs persistent context handling

#### 5. **Configuration Propagation Tests** (~2 tests)
Test how configuration changes affect system behavior:
- Enable/disable features in track.config.json
- Settings.json hook configuration
- Feature flag interactions

### Implementation Approach

#### Test Infrastructure (`src/test-utils/integration-helpers.ts`)
```typescript
- createTempGitRepo(): Initialize temp git repo with commits
- createTempProject(): Set up full cc-track project structure
- runHookChain(): Execute multiple hooks in sequence
- captureSystemState(): Snapshot files, git state, logs
- ClaudeSDKStub: Controllable stub for Claude API calls
- GitHubAPIStub: Mock GitHub operations with validation
```

#### Test Organization
```
src/integration-tests/
├── task-lifecycle.test.ts      # Full task workflows
├── hook-chains.test.ts         # Multi-hook interactions
├── git-operations.test.ts      # Real git operations
├── context-management.test.ts  # Context file handling
└── config-propagation.test.ts  # Configuration effects
```

#### Example Test Structure
```typescript
// Task lifecycle test
test('complete task workflow with GitHub integration', async () => {
  const { projectDir, cleanup } = await createTempProject({
    gitInit: true,
    githubEnabled: true
  });
  
  // Capture plan
  const planOutput = await runHook('capture-plan', { 
    exitPlanModeData: mockPlan 
  });
  
  // Verify task file created, branch switched, issue created
  expect(await getActiveTask()).toBe('TASK_001');
  expect(await getCurrentBranch()).toBe('feature/task-001');
  
  // Simulate development with edits
  await editFile('src/index.ts', 'new content');
  await runHook('stop-review');
  
  // Complete task
  await runCommand('complete-task');
  
  // Verify final state
  expect(await getCurrentBranch()).toBe('main');
  expect(await getPRStatus()).toBe('open');
  
  cleanup();
});
```

### Benefits
1. **Catch interaction bugs**: Unit tests miss issues that arise from component interactions
2. **Validate real workflows**: Test actual user journeys, not just isolated functions
3. **Regression prevention**: Ensure complex workflows don't break with changes
4. **Documentation**: Tests serve as executable documentation of system behavior
5. **Confidence**: Higher confidence in releases and refactoring

### Implementation Priority
1. Start with task lifecycle tests (highest value)
2. Add hook chain tests (catch most integration bugs)
3. Add git operations tests (critical for reliability)
4. Add context and config tests (lower priority)

### Estimated Effort
- Infrastructure setup: 4-6 hours
- Test implementation: 8-10 hours
- Total: ~2 days of focused work

These integration tests would complement the existing unit tests perfectly, providing confidence that the system works end-to-end while maintaining fast unit tests for rapid feedback during development.